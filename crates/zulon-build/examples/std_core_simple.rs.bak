// Copyright 2026 ZULON Language Team
// SPDX-License-Identifier: Apache-2.0 OR MIT

//! Comprehensive demonstration of zulon-std-core library

use zulon_std_core::{Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Ordering};
use zulon_std_core::Optional;
use zulon_std_core::Outcome;

fn main() {
    println!("=== ZULON Standard Library Core Demo ===\n");

    // =========================================================================
    // Part 1: Trait Demonstrations
    // =========================================================================
    println!("1. CORE TRAITS DEMONSTRATION");
    println!("   --------------------------\n");

    // Clone and Copy traits
    println!("   a) Clone and Copy Traits:");
    let x = 42i32;
    let y = x.clone(); // Clone
    let z = x;         // Copy (implicit)
    println!("      Original: {}, Clone: {}, Copy: {}", x, y, z);

    // PartialEq trait
    println!("\n   b) PartialEq Trait:");
    println!("      42 == 42: {}", 42_i32.eq(&42));
    println!("      42 != 43: {}", 42_i32.ne(&43));

    // PartialOrd trait
    println!("\n   c) PartialOrd Trait:");
    println!("      42 < 43: {}", 42_i32.lt(&43));
    println!("      partial_cmp(42, 43): {:?}", 42_i32.partial_cmp(&43));

    // Ord trait
    println!("\n   d) Ord Trait:");
    println!("      cmp(42, 43): {:?}", 42_i32.cmp(&43));

    // =========================================================================
    // Part 2: Optional<T> Demonstrations
    // =========================================================================
    println!("\n2. OPTIONAL<T> TYPE DEMONSTRATION");
    println!("   ------------------------------\n");

    // Creating Optional values
    println!("   a) Creating Optional Values:");
    let some_value: Optional<i32> = Optional::Some(42);
    let no_value: Optional<i32> = Optional::None;
    println!("      Some(42) = {:?}", some_value);
    println!("      None = {:?}", no_value);

    // Checking Optional state
    println!("\n   b) Checking Optional State:");
    println!("      Some(42).is_some(): {}", some_value.is_some());
    println!("      Some(42).is_none(): {}", some_value.is_none());

    // Unwrapping Optional values
    println!("\n   c) Unwrapping Optional Values:");
    println!("      Some(42).unwrap(): {}", some_value.unwrap());
    println!("      Some(42).unwrap_or(100): {}", Some(42).unwrap_or(100));
    println!("      None.unwrap_or(100): {}", no_value.unwrap_or(100));

    // Mapping Optional values
    println!("\n   d) Mapping Optional Values:");
    let doubled = Some(42).map(|x| x * 2);
    println!("      Some(42).map(|x| x * 2) = {:?}", doubled);

    // Chaining Optional operations
    println!("\n   e) Chaining Optional Operations:");
    fn maybe_divide(x: i32, y: i32) -> Optional<i32> {
        if y == 0 { None } else { Some(x / y) }
    }
    let result = Some(100).and_then(|x| maybe_divide(x, 2));
    println!("      100 / 2 = {:?}", result);
    let failed = Some(100).and_then(|x| maybe_divide(x, 0));
    println!("      100 / 0 = {:?}", failed);

    // =========================================================================
    // Part 3: Outcome<T, E> Demonstrations
    // =========================================================================
    println!("\n3. OUTCOME<T, E> TYPE DEMONSTRATION");
    println!("   -------------------------------\n");

    // Creating Outcome values
    println!("   a) Creating Outcome Values:");
    let success: Outcome<i32, &str> = Ok(42);
    let failure: Outcome<i32, &str> = Err("Something went wrong");
    println!("      Ok(42) = {:?}", success);
    println!("      Err(\"error\") = {:?}", failure);

    // Checking Outcome state
    println!("\n   b) Checking Outcome State:");
    println!("      Ok(42).is_ok(): {}", success.is_ok());
    println!("      Ok(42).is_err(): {}", success.is_err());

    // Unwrapping Outcome values
    println!("\n   c) Unwrapping Outcome Values:");
    println!("      Ok(42).unwrap(): {}", success.unwrap());
    println!("      Ok(42).unwrap_or(100): {}", Ok(42).unwrap_or(100));

    // Mapping Outcome values
    println!("\n   d) Mapping Outcome Values:");
    let doubled = Ok(42).map(|x| x * 2);
    println!("      Ok(42).map(|x| x * 2) = {:?}", doubled);

    // Chaining Outcome operations
    println!("\n   e) Chaining Outcome Operations:");
    fn divide_and_square(x: i32, y: i32) -> Outcome<i32, &'static str> {
        if y == 0 { Err("Division by zero") } else { Ok((x / y) * (x / y)) }
    }
    let chained = Ok(100).and_then(|x| divide_and_square(x, 5));
    println!("      divide_and_square(100, 5) = {:?}", chained);

    // =========================================================================
    // Part 4: Real-World Example - Safe Division
    // =========================================================================
    println!("\n4. REAL-WORLD EXAMPLE: SAFE DIVISION");
    println!("   ------------------------------------\n");

    fn safe_divide(a: i32, b: i32) -> Outcome<i32, String> {
        if b == 0 {
            Err(format!("Cannot divide {} by {}", a, b))
        } else {
            Ok(a / b)
        }
    }

    println!("   Calculating 100 / 5:");
    match safe_divide(100, 5) {
        Ok(result) => println!("      Success! Result = {}", result),
        Err(e) => println!("      Error: {}", e),
    }

    println!("\n   Calculating 100 / 0:");
    match safe_divide(100, 0) {
        Ok(result) => println!("      Success! Result = {}", result),
        Err(e) => println!("      Error: {}", e),
    }

    // =========================================================================
    // Summary
    // =========================================================================
    println!("\n=== SUMMARY ===");
    println!("âœ“ Core Traits: Clone, Copy, PartialEq, Eq, PartialOrd, Ord");
    println!("âœ“ Optional<T>: Optional values without null pointers");
    println!("âœ“ Outcome<T, E>: Error handling with Result types");
    println!("\nZULON Standard Library Core is fully functional! ðŸŽ‰\n");
}
