// Copyright 2026 ZULON Language Team
// SPDX-License-Identifier: Apache-2.0 OR MIT

//! Integration tests for complete LLVM IR generation

use std::io::Cursor;
use zulon_codegen_llvm::{CodeGenerator, CallingConvention, StructLayout, EnumLayout};
use zulon_lir::{LirFunction, LirBlock, LirInstruction, LirTerminator, LirTy};
use std::collections::HashMap;
use zulon_lir::LirBinOp;

#[test]
fn test_simple_function_generation() {
    // Create a simple add function: fn add(a: i32, b: i32) -> i32 { a + b }
    let mut func = LirFunction {
        name: "add".to_string(),
        params: vec![0, 1],  // v0, v1
        param_types: vec![LirTy::I32, LirTy::I32],
        return_type: LirTy::I32,
        blocks: HashMap::new(),
        entry_block: 0,
        next_id: 1,
        next_vreg: 2,
        external_funcs: Vec::new(),
    };

    // Create entry block
    let block = LirBlock {
        id: 0,
        phi_nodes: HashMap::new(),
        instructions: vec![
            // %v2 = add i32 %v0, %v1
            LirInstruction::BinaryOp {
                dest: 2,
                op: LirBinOp::Add,
                left: 0,
                right: 1,
                ty: LirTy::I32,
            },
        ],
        terminator: Some(LirTerminator::Return(Some(2))),
    };

    func.blocks.insert(0, block);

    // Generate LLVM IR
    let mut buffer = Cursor::new(Vec::new());
    let mut codegen = CodeGenerator::new(&mut buffer);
    codegen.generate_function(&func).unwrap();

    // Verify output
    let output = String::from_utf8(buffer.into_inner()).unwrap();
    println!("Generated LLVM IR:\n{}", output);

    assert!(output.contains("define i32 @add(i32 %v0, i32 %v1)"));
    assert!(output.contains("%v2 = add i32 %v0, %v1"));
    assert!(output.contains("ret i32 %v2"));
}

#[test]
fn test_module_generation() {
    // Create two functions
    let mut add_func = LirFunction {
        name: "add".to_string(),
        params: vec![0, 1],
        param_types: vec![LirTy::I32, LirTy::I32],
        return_type: LirTy::I32,
        blocks: HashMap::new(),
        entry_block: 0,
        next_id: 1,
        next_vreg: 2,
        external_funcs: Vec::new(),
    };

    let add_block = LirBlock {
        id: 0,
        phi_nodes: HashMap::new(),
        instructions: vec![
            LirInstruction::BinaryOp {
                dest: 2,
                op: LirBinOp::Add,
                left: 0,
                right: 1,
                ty: LirTy::I32,
            },
        ],
        terminator: Some(LirTerminator::Return(Some(2))),
    };
    add_func.blocks.insert(0, add_block);

    let mut sub_func = LirFunction {
        name: "sub".to_string(),
        params: vec![3, 4],
        param_types: vec![LirTy::I32, LirTy::I32],
        return_type: LirTy::I32,
        blocks: HashMap::new(),
        entry_block: 1,
        next_id: 2,
        next_vreg: 5,
        external_funcs: Vec::new(),
    };

    let sub_block = LirBlock {
        id: 1,
        phi_nodes: HashMap::new(),
        instructions: vec![
            LirInstruction::BinaryOp {
                dest: 5,
                op: LirBinOp::Sub,
                left: 3,
                right: 4,
                ty: LirTy::I32,
            },
        ],
        terminator: Some(LirTerminator::Return(Some(5))),
    };
    sub_func.blocks.insert(1, sub_block);

    // Generate module
    let mut buffer = Cursor::new(Vec::new());
    let mut codegen = CodeGenerator::new(&mut buffer);
    codegen.generate_module(&[add_func, sub_func]).unwrap();

    // Verify output
    let output = String::from_utf8(buffer.into_inner()).unwrap();
    println!("Generated LLVM IR Module:\n{}", output);

    assert!(output.contains("; Generated by ZULON compiler"));
    assert!(output.contains("define i32 @add"));
    assert!(output.contains("define i32 @sub"));
}

#[test]
fn test_abi_function_generation() {
    // Test function with ABI information
    let mut func = LirFunction {
        name: "compute".to_string(),
        params: vec![0, 1, 2],  // 3 parameters
        param_types: vec![LirTy::I32, LirTy::I64, LirTy::I32],
        return_type: LirTy::I64,
        blocks: HashMap::new(),
        entry_block: 0,
        next_id: 1,
        next_vreg: 3,
        external_funcs: Vec::new(),
    };

    let block = LirBlock {
        id: 0,
        phi_nodes: HashMap::new(),
        instructions: vec![],
        terminator: Some(LirTerminator::Return(Some(1))),  // Return second param (i64)
    };
    func.blocks.insert(0, block);

    // Generate with System V AMD64 ABI
    let mut buffer = Cursor::new(Vec::new());
    let mut codegen = CodeGenerator::new(&mut buffer)
        .with_calling_convention(CallingConvention::SystemVAMD64);

    codegen.generate_function_with_abi(&func).unwrap();

    let output = String::from_utf8(buffer.into_inner()).unwrap();
    println!("Generated LLVM IR with ABI:\n{}", output);

    assert!(output.contains("define i64 @compute"));
    assert!(output.contains("i32 %v0"));
    assert!(output.contains("i64 %v1"));
    assert!(output.contains("i32 %v2"));
}

#[test]
fn test_struct_type_declaration() {
    // Create a struct type
    let mut layout = StructLayout::new("Point".to_string());
    layout.add_field("x".to_string(), LirTy::F32).unwrap();
    layout.add_field("y".to_string(), LirTy::F32).unwrap();
    layout.finalize();

    // Create a simple function
    let mut func = LirFunction {
        name: "get_x".to_string(),
        params: vec![0],
        param_types: vec![LirTy::Ptr(Box::new(LirTy::F32))],
        return_type: LirTy::F32,
        blocks: HashMap::new(),
        entry_block: 0,
        next_id: 1,
        next_vreg: 1,
        external_funcs: Vec::new(),
    };

    let block = LirBlock {
        id: 0,
        phi_nodes: HashMap::new(),
        instructions: vec![],
        terminator: Some(LirTerminator::Return(None)),
    };
    func.blocks.insert(0, block);

    // Generate with struct type
    let mut buffer = Cursor::new(Vec::new());
    let mut codegen = CodeGenerator::new(&mut buffer);
    codegen.register_struct(layout);
    codegen.generate_module(&[func]).unwrap();

    let output = String::from_utf8(buffer.into_inner()).unwrap();
    println!("Generated LLVM IR with struct:\n{}", output);

    assert!(output.contains("%struct.Point"));
    assert!(output.contains("float"));
}

#[test]
fn test_enum_type_declaration() {
    // Create an enum type
    let mut layout = EnumLayout::new("Option".to_string(), LirTy::I8);
    layout.add_variant("None".to_string(), 0, vec![]).unwrap();
    layout.add_variant("Some".to_string(), 1, vec![
        ("value".to_string(), LirTy::I32)
    ]).unwrap();
    layout.finalize();

    // Create a simple function
    let mut func = LirFunction {
        name: "is_some".to_string(),
        params: vec![0],
        param_types: vec![LirTy::Ptr(Box::new(LirTy::I8))],
        return_type: LirTy::Bool,
        blocks: HashMap::new(),
        entry_block: 0,
        next_id: 1,
        next_vreg: 1,
        external_funcs: Vec::new(),
    };

    let block = LirBlock {
        id: 0,
        phi_nodes: HashMap::new(),
        instructions: vec![],
        terminator: Some(LirTerminator::Return(None)),
    };
    func.blocks.insert(0, block);

    // Generate with enum type
    let mut buffer = Cursor::new(Vec::new());
    let mut codegen = CodeGenerator::new(&mut buffer);
    codegen.register_enum(layout);
    codegen.generate_module(&[func]).unwrap();

    let output = String::from_utf8(buffer.into_inner()).unwrap();
    println!("Generated LLVM IR with enum:\n{}", output);

    assert!(output.contains("%enum.Option"));
}
