// error_handling_parser_demo.zl
// Demonstrates the new error handling syntax supported by the parser
// Note: Parser support is 100% complete, but runtime/codegen support is pending
//
// This file demonstrates the SYNTAX that can now be parsed correctly.
// To actually RUN these examples, we need to complete HIR/MIR/Codegen integration.

// ============================================================================
// Example 1: Simple throw statement
// ============================================================================

fn divide_simple(a: i32, b: i32) -> i32 | DivideError {
    if b == 0 {
        throw DivideError::Zero;
    }
    Outcome::Ok(a / b)
}

// ============================================================================
// Example 2: Error type with multiple variants
// ============================================================================

fn divide_detailed(a: i32, b: i32) -> i32 | DivideError {
    if b == 0 {
        throw DivideError::Zero;
    }
    if a < 0 || b < 0 {
        throw DivideError::Negative;
    }
    Outcome::Ok(a / b)
}

// ============================================================================
// Example 3: Question mark operator for error propagation
// ============================================================================

fn calculate() -> i32 | DivideError {
    let x = divide_simple(100, 2)?;
    let y = divide_detailed(x, 5)?;
    Outcome::Ok(y)
}

// ============================================================================
// Example 4: Chained question mark operators
// ============================================================================

fn complex_calculation() -> i32 | DivideError {
    let result = divide_simple(divide_detailed(1000, 10)?, 2)?;
    Outcome::Ok(result)
}

// ============================================================================
// Example 5: Question mark in expression position
// ============================================================================

fn add_with_division(a: i32, b: i32, c: i32) -> i32 | DivideError {
    let quotient = divide_simple(a, b)?;
    Outcome::Ok(quotient + c)
}

// ============================================================================
// Example 6: Simple error type only (no effects)
// ============================================================================

fn parse_number(s: string) -> i32 | ParseError {
    // This would parse a string to i32
    // For now, just return a placeholder
    Outcome::Ok(42)
}

// ============================================================================
// Example 7: Error type with single effect
// ============================================================================

fn read_file(path: string) -> string | IoError | IoEffect {
    // This would read a file
    // IoEffect indicates this function performs I/O
    Outcome::Ok("file contents")
}

// ============================================================================
// Example 8: Error type with multiple effects
// ============================================================================

fn process_data() -> i32 | ProcessError | IoEffect + DatabaseEffect + LogEffect {
    // This demonstrates multiple effects combined with +
    let data = read_file("data.txt")?;
    Outcome::Ok(42)
}

// ============================================================================
// Example 9: Nested question marks
// ============================================================================

fn outer_function() -> i32 | DivideError {
    let result = inner_function(divide_simple(10, 2)?)?;
    Outcome::Ok(result)
}

fn inner_function(x: i32) -> i32 | DivideError {
    Outcome::Ok(x * 2)
}

// ============================================================================
// Example 10: Generic function with error type
// ============================================================================

fn process<T>(value: T) -> T | ProcessError {
    // Generic function that can fail
    Outcome::Ok(value)
}

// ============================================================================
// Example 11: Using match with question mark
// ============================================================================

fn match_with_question(input: i32) -> i32 | DivideError {
    let result = match input {
        0 => divide_simple(10, 2)?,
        1 => divide_detailed(20, 4)?,
        _ => divide_simple(100, 10)?
    };
    Outcome::Ok(result)
}

// ============================================================================
// Example 12: Multiple sequential operations with ?
// ============================================================================

fn pipeline() -> i32 | DivideError {
    let step1 = divide_simple(100, 2)?;
    let step2 = divide_detailed(step1, 5)?;
    let step3 = divide_simple(step2, 2)?;
    Outcome::Ok(step3)
}

// ============================================================================
// Main function (traditional approach for now)
// ============================================================================

fn main() -> i32 {
    // Current approach: Use Outcome<T, E> type explicitly
    // until code generation for throw/? is complete

    // Example of current manual error handling:
    let result = safe_divide(10, 2);

    match result {
        Outcome::Ok(value) => {
            // Success!
            0
        },
        Outcome::Err(_) => {
            // Error!
            1
        }
    }
}

// Traditional implementation using Outcome type
fn safe_divide(a: i32, b: i32) -> Outcome<i32, DivideError> {
    if b == 0 {
        Outcome::Err(DivideError::Zero)
    } else {
        Outcome::Ok(a / b)
    }
}

// ============================================================================
// Note: This file demonstrates PARSER capabilities only
// ============================================================================
//
// What works RIGHT NOW (100% complete):
//   ✅ Parser can parse all syntax above
//   ✅ AST structure supports throw, ?, | separators
//   ✅ All 50 parser tests passing
//
// What needs to be implemented (pending):
//   ⏳ HIR lowering for error_type and effects
//   ⏳ Type checking for throw and ? expressions
//   ⏳ MIR lowering for control flow
//   ⏳ LLVM code generation
//   ⏳ Standard library Outcome<T, E> type
//   ⏳ Standard library Error trait
//
// See ERROR_HANDLING_STATUS.md for detailed implementation roadmap
