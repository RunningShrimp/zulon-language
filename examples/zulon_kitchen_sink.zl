// Zulon 可读性优先示例（design v2.2）
// 目标：一份“稍完整但不吓人”的样例——像 Go/Python 一样按顺序读。
// 保留核心：effects+handlers、T?/??、T!E/?、region、share、task::scope。
// 刻意不展示：trait/const 泛型、SIMD、列表推导/管道、dynamic/cast、复杂 ADT。

// ----- Errors / Domain -----

enum IoError { NotFound, Permission, Other(str) }

enum NetError { Timeout, Dns, Other(str) }

enum AppError {
  BadRequest,
  Io(IoError),
  Net(NetError),
}

struct Config {
  name: str,
  endpoint: Url,
  retries: i32,
}

struct Request {
  user_id: i64?,
  token: str?,
}

struct Response {
  status: i32,
  body: str,
}

// ----- Effects (能力接口) -----

effect IO {
  fn write(path: Path, data: Bytes) -> usize ! IoError;
}

effect Net {
  fn get(u: Url) -> Bytes ! NetError;
}

// ----- Parsing / Validation -----

fn parse_field(text: str, key: str) -> str? {
  let pat = key + "=";
  let i = text.find(pat);
  if i < 0 { return null; }
  let rest = text.slice(i + pat.len(), text.len());
  let j = rest.find(";");
  if j < 0 { return rest; }
  return rest.slice(0, j);
}

fn parse_i32(text: str) -> i32? {
  // 这是示例：把“可能解析失败”写成可空返回，让调用方用 `??` 决定默认值。
  match i32::parse(text) {
    case Ok(v) => v,
    case Err(_) => null,
  }
}

fn parse_config(text: str)
  -> Config
  | throws AppError {
  let name = parse_field(text, "name") ?? return Err(AppError::BadRequest);
  let endpoint_s = parse_field(text, "endpoint") ?? return Err(AppError::BadRequest);
  let retries_s = parse_field(text, "retries") ?? "3";

  let endpoint: Url = Url::parse(endpoint_s).map_err(|_| AppError::BadRequest)?;
  let retries: i32 = parse_i32(retries_s) ?? 3;

  return Ok(Config { name, endpoint, retries });
}

fn auth(req: Request)
  -> i64
  | throws AppError {
  let t = req.token ?? return Err(AppError::BadRequest);
  if t.len() == 0 { return Err(AppError::BadRequest); }
  let uid = req.user_id ?? return Err(AppError::BadRequest);
  return Ok(uid);
}

fn handle_request(req: Request)
  -> Response
  | throws AppError {
  // region：把“请求处理过程中的临时分配”收敛在一个作用域里。
  region req_scope {
    let uid = auth(req)?;
    let body = "hello uid=" + uid.to_string();
    return Ok(Response { status: 200, body });
  }
}

// ----- Networking -----

fn fetch_once(u: Url)
  -> Bytes
  | throws NetError
  | uses Net {
  return do Net::get(u);
}

fn fetch_with_retry(u: Url, retries: i32)
  -> Bytes
  | throws NetError
  | uses Net {
  // 更像“脚本语言的直觉写法”：用显式参数表达策略，而不是再引入一个 Retry effect。
  let mut attempt = 0;
  loop {
    attempt += 1;
    match fetch_once(u) {
      case Ok(b) => return Ok(b),
      case Err(e) => {
        if attempt >= retries { return Err(e); }
        continue;
      }
    }
  }
}

// ----- App -----

fn run(cfg_text: str, req: Request)
  -> Response
  | throws AppError
  | uses IO + Net {
  let cfg = parse_config(cfg_text)?;
  let cfg = share(cfg);

  let _ = do IO::write("/tmp/zulon.log", ("boot " + cfg.name).bytes())
    .map_err(|e| AppError::Io(e))?;

  return task::scope {
    // 并发部分只做一件事：并行拉取两个资源，然后继续顺序业务逻辑。
    let h1 = task::spawn {
      fetch_with_retry(cfg.endpoint, cfg.retries).map_err(|e| AppError::Net(e))
    };
    let h2 = task::spawn {
      fetch_with_retry(cfg.endpoint, cfg.retries).map_err(|e| AppError::Net(e))
    };

    let resp = handle_request(req)?;

    let _ = h1.await?;
    let _ = h2.await?;

    return resp;
  };
}

// ----- Entrypoints -----

fn start() throws AppError {
  let cfg_text = "name=demo;endpoint=https://example.com;retries=3";
  let req = Request { user_id: 1, token: "t" };

  let resp = handle run(cfg_text, req) {
    case IO::write(p, b) => resume(io_runtime::write(p, b)),
    case Net::get(u) => resume(net_runtime::get(u)),
  }?;

  println(resp.body);
  return Ok(());
}

fn main() throws AppError {
  start()?;
  return Ok(());
}

