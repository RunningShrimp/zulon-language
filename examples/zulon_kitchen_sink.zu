// NOTE: This is a review-oriented sample program for the Zulon language design v2.2.
// It intentionally exercises most language elements in one place.

// ---------- Core ADTs / Errors ----------

enum Option<T> { Some(T), None }

enum AppError {
  Io(IoError),
  Net(NetError),
  Json(JsonError),
  Config(ConfigError),
}

enum ConfigError { MissingField(String), Invalid(String) }

enum JsonError { BadFormat, Missing(String), Type(String) }

enum IoError { NotFound, Permission, Other(String) }

enum NetError { Timeout, Dns, Other(String) }

enum RequestError { BadRequest, Unauthorized }

enum ResponseError { Internal }

struct Config {
  name: String,
  endpoint: Url,
  retries: i32,
}

struct Request {
  user_id: i64?,
  token: String?,
  body: String,
}

struct Response {
  status: i32,
  body: String,
}

// ---------- Traits / Generics / Const generics ----------

trait Add {
  type Output;
  fn add(self, rhs: Self) -> Self::Output;
}

fn add<T>(a: T, b: T) -> T
where T: Add<Output = T> {
  return a + b;
}

trait Matrix<T> {
  const ROWS: usize;
  const COLS: usize;
  type Output;
  fn mul(self, other: Self) -> Self::Output;
}

// ---------- Effects (capabilities) ----------

effect IO {
  fn write(path: Path, data: Bytes) -> usize ! IoError;
  fn read(path: Path) -> Bytes ! IoError;
}

effect Net {
  fn get(u: Url) -> Bytes ! NetError;
}

effect Retry {
  fn should_retry(attempt: i32, err: String) -> bool;
}

effect Json {
  fn parse(text: String) -> dynamic ! JsonError;
}

// ---------- Effect polymorphism (P0 form) ----------

fn map<T, U, E>(xs: List<T>, f: fn(T) -> U performs E) -> List<U> performs E {
  let mut out = List::new();
  for x in xs { out.push(f(x)); }
  return out;
}

fn with_logging<E, T>(tag: String, f: fn() -> T performs E) -> T performs E {
  // logging is done by the caller via handler, so this wrapper stays generic
  return f();
}

// ---------- Null-safety, dynamic boundary, and casting ----------

fn parse_config(text: String) -> Config ! ConfigError performs Json {
  let x: dynamic = do Json::parse(text)?;

  let name: String = cast<String>(x.name).map_err(|_| ConfigError::MissingField("name"))?;
  let endpoint: Url = cast<Url>(x.endpoint).map_err(|_| ConfigError::MissingField("endpoint"))?;

  let retries_opt: i32? = cast<i32?>(x.retries).map_err(|_| ConfigError::Invalid("retries"))?;
  let retries: i32 = retries_opt ?? 3;

  return Config { name, endpoint, retries };
}

fn auth_user(req: Request) -> i64 ! RequestError {
  let token = req.token ?? return Err(RequestError::Unauthorized);
  if token.len() == 0 { return Err(RequestError::Unauthorized); }

  let uid = req.user_id ?? return Err(RequestError::BadRequest);
  return Ok(uid);
}

// ---------- UMCA: region + share/freeze ----------

fn handle_request(req: Request) -> Response ! (RequestError | ResponseError) {
  region req_scope {
    let uid = auth_user(req)?;
    let body = "hello user=" + uid.to_string();
    return Ok(Response { status: 200, body });
  }
}

fn freeze_config(cfg: Config) -> shared Config {
  return share(cfg);
}

// ---------- Concurrency: task::scope, spawn, cancellation semantics ----------

fn fetch(u: Url) -> Bytes ! NetError performs Net + Retry {
  let mut attempt = 0;
  loop {
    attempt += 1;
    match do Net::get(u) {
      case Ok(b) => return Ok(b),
      case Err(e) => {
        if do Retry::should_retry(attempt, e.to_string()) { continue; }
        return Err(e);
      }
    }
  }
}

actor Counter {
  state n: i64

  fn inc(self, by: i64) -> i64 {
    self.n = self.n + by;
    return self.n;
  }
}

fn pipeline_demo(xs: List<i32>) -> List<i32> {
  // pipe + list expression
  let ys = xs |> (|v| v + 1);
  let zs = [x*x for x in ys if x % 2 == 0];
  return zs;
}

fn simd_demo(a: v4f32, b: v4f32) -> v4f32 {
  let c = a + b;
  return c;
}

fn run_app(cfg_text: String, req: Request) -> Response ! AppError performs IO + Net + Retry + Json {
  let cfg = parse_config(cfg_text).map_err(|e| AppError::Config(e))?;
  let cfg = freeze_config(cfg);

  let _ = do IO::write("/tmp/zulon.log", ("boot " + cfg.name).bytes())
    .map_err(|e| AppError::Io(e))?;

  // Structured concurrency: parallel fetch + request handling
  let resp = task::scope {
    let counter = Counter { n: 0 };

    let h1 = task::spawn { with_logging("fetch1", || fetch(cfg.endpoint)) };
    let h2 = task::spawn { with_logging("fetch2", || fetch(cfg.endpoint)) };

    let r = handle_request(req)
      .map_err(|_| AppError::Json(JsonError::BadFormat))?;

    let _b1 = h1.await.map_err(|e| AppError::Net(e))?;
    let _b2 = h2.await.map_err(|e| AppError::Net(e))?;

    let _ = counter.inc(1);

    return r;
  };

  return Ok(resp);
}

// ---------- Entrypoints: start (script) + main (system) ----------

fn start() ! AppError {
  let cfg_text = "{ \"name\": \"demo\", \"endpoint\": \"https://example.com\", \"retries\": 3 }";
  let req = Request { user_id: 1, token: "t", body: "{}" };

  // Example detached background task must be consumed.
  let h = task::spawn_detached { Ok(()) };
  let _ = h.await;

  let resp = handle run_app(cfg_text, req) {
    // Json effect: very small illustrative parser handler
    case Json::parse(text) => resume(json_runtime::parse(text)),

    // IO effect: delegate to runtime
    case IO::write(p, b) => resume(io_runtime::write(p, b)),
    case IO::read(p) => resume(io_runtime::read(p)),

    // Net effect: delegate to runtime
    case Net::get(u) => resume(net_runtime::get(u)),

    // Retry policy: at most cfg.retries attempts (fallback: 3)
    case Retry::should_retry(attempt, err) => resume(attempt < 3),
  };

  println(resp.body);
  return Ok(());
}

fn main() ! AppError {
  return start()?;
}
