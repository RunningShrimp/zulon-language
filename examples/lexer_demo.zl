// ZULON Lexer æ¼”ç¤ºç¨‹åº
// è¿™ä¸ªæ–‡ä»¶å±•ç¤ºå„ç§ Token ç±»å‹ï¼Œç”¨äºæµ‹è¯•è¯æ³•åˆ†æå™¨

// 1. å…³é”®å­—æ¼”ç¤º
fn demo_keywords() {
    // æ§åˆ¶æµ
    if condition {
        loop {
            while true {
                for item in items {
                    break;
                    continue;
                }
                return;
            }
        }
    } else {
        match value {
            _ => {}
        }
    }

    // å£°æ˜
    fn function() {}
    struct Point {}
    enum Option {}
    trait Display {}
    impl Type for Trait {}
    type Alias = i32;

    let mut variable = 42;
    const CONSTANT: i32 = 100;
    static STATIC: i32 = 200;

    // ä¿®é¥°ç¬¦
    pub fn public_function() {}
    use std::collections;
    mod my_module {}
    where T: Display;

    // é”™è¯¯å’Œæ•ˆåº”
    error MyError {}
    effect IO {}
    throw MyError::Invalid;
    perform IO::write();
    try {
        risky_operation()
    }
}

// 2. è¿ç®—ç¬¦æ¼”ç¤º
fn demo_operators() {
    // ç®—æœ¯è¿ç®—ç¬¦
    let a = 10 + 20;
    let b = 30 - 15;
    let c = 5 * 6;
    let d = 100 / 4;
    let e = 17 % 5;
    let f = 2 ^ 10;

    // èµ‹å€¼è¿ç®—ç¬¦
    a += 10;
    b -= 5;
    c *= 2;
    d /= 3;
    e %= 4;
    f ^= 5;

    // æ¯”è¾ƒè¿ç®—ç¬¦
    let eq = (x == y);
    let ne = (x != y);
    let lt = (x < y);
    let le = (x <= y);
    let gt = (x > y);
    let ge = (x >= y);

    // é€»è¾‘è¿ç®—ç¬¦
    let and_val = (true && false);
    let or_val = (true || false);
    let not_val = !true;

    // ä½è¿ç®—ç¬¦
    let bit_and = (x & y);
    let bit_or = (x | y);
    let left_shift = (x << 2);
    let right_shift = (x >> 2);

    // å…¶ä»–è¿ç®—ç¬¦
    let arrow = || -> ReturnType {};
    let dot = object.method();
    let range = 0..10;
    let range_inclusive = 0..=10;
    let spread = ...args;
    let path = std::collections::HashMap;
    let nullable = value?;
}

// 3. å­—é¢é‡æ¼”ç¤º
fn demo_literals() {
    // æ•´æ•°
    let decimal = 42;
    let hex = 0xFF;
    let binary = 0b1010;
    let octal = 0o755;
    let with_underscores = 1_000_000;

    // æµ®ç‚¹æ•°
    let float = 3.14;
    let scientific = 1.5e10;
    let with_suffix = 3.14f64;

    // å­—ç¬¦ä¸²
    let string = "Hello, World!";
    let multiline = "Line 1\nLine 2\nLine 3";
    let escaped = "Tab:\t, Quote:\", Backslash:\\\\";

    // æ¨¡æ¿å­—ç¬¦ä¸²
    let name = "Alice";
    let greeting = `Hello, ${name}!`;
    let multiline_template = `
        Dear ${name},

        Welcome to ZULON!

        Best regards,
        The ZULON Team
    `;

    // å­—ç¬¦
    let char = 'a';
    let newline = '\n';
    let unicode = 'ğŸ˜€';
    let escape = '\\';

    // å¸ƒå°”å€¼
    let true_val = true;
    let false_val = false;

    // ç©ºå€¼
    let null_val = null;

    // æ•°ç»„ï¼ˆè¯­æ³•æ¼”ç¤ºï¼‰
    let arr = [1, 2, 3, 4, 5];
    let slice = &arr[1..4];
}

// 4. æ³¨é‡Šæ¼”ç¤º
// è¿™æ˜¯å•è¡Œæ³¨é‡Š

/*
 * è¿™æ˜¯
 * å¤šè¡Œ
 * æ³¨é‡Š
 */

// 5. åˆ†éš”ç¬¦æ¼”ç¤º
fn demo_delimiters() {
    // æ‹¬å·
    let tuple = (1, 2, 3);
    let array = [1, 2, 3];
    let block = { let x = 42; };

    // æ ‡ç‚¹
    let result = function(arg1, arg2);
    let mut value: Type = 100;
    let path: module::Type;

    // å±æ€§
    #[derive(Debug)]
    struct Example {}

    @attribute
    fn decorated() {}
}

// 6. ä¸»å‡½æ•°æ¼”ç¤º
fn main() {
    // æ¼”ç¤ºå„ç§ç‰¹æ€§
    demo_keywords();
    demo_operators();
    demo_literals();
    demo_delimiters();

    // æ¨¡æ¿å­—ç¬¦ä¸²æ’å€¼
    let name = "World";
    println(`Hello, ${name}!`);

    // é”™è¯¯å¤„ç†
    let result = risky_operation()?;
    match result {
        Ok(value) => println!("Success: {}", value),
        Err(e) => println!("Error: {}", e),
    }
}
