// Test end-to-end compilation pipeline

use zulon_parser::Parser;

fn main() {
    println!("=== ZULON Compilation Pipeline Test ===\n");

    let source = r#"
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn new(x: i32, y: i32) -> Self {
        Point { x, y }
    }

    fn distance(&self, other: &Point) -> f64 {
        let dx = (self.x - other.x) as f64;
        let dy = (self.y - other.y) as f64;
        (dx * dx + dy * dy).sqrt()
    }
}

fn main() {
    let p1 = Point::new(0, 0);
    let p2 = Point::new(3, 4);
    let dist = p1.distance(&p2);

    if dist > 5.0 {
        println!("Far!");
    } else {
        println!("Close!");
    }
}
"#;

    println!("Source code:");
    println!("{}", source);
    println!("\n--- Parsing ---");

    // Step 1: Parse source code
    let mut parser = Parser::from_source(source);
    match parser.parse() {
        Ok(ast) => {
            println!("✅ Parsing successful!");
            println!("   AST items: {}", ast.items.len());

            for (i, item) in ast.items.iter().enumerate() {
                println!("   [{}] {:?}", i, item.kind);
            }
        }
        Err(e) => {
            eprintln!("❌ Parse error: {}", e);
            return;
        }
    }

    println!("\n--- Summary ---");
    println!("✅ Lexer + Parser working correctly!");
    println!("✅ AST generated successfully!");
    println!("\nNext steps:");
    println!("  1. Type checking (zulon-typeck)");
    println!("  2. HIR lowering (zulon-hir)");
    println!("  3. MIR lowering (zulon-mir)");
    println!("  4. LIR lowering (zulon-lir)");
    println!("  5. Code generation (zulon-codegen-llvm)");
}
