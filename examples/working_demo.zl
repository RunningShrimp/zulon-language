// working_demo.zl
// Demonstrates what ACTUALLY WORKS in ZULON as of 2026-01-08
// All examples in this file are fully functional and can be compiled/run

// ============================================================================
// Example 1: Hello World
// ============================================================================

fn say_hello() -> i32 {
    println("Hello, World!");
    0
}

// ============================================================================
// Example 2: Arithmetic Operations
// ============================================================================

fn arithmetic_demo() -> i32 {
    let a = 10;
    let b = 20;
    let sum = a + b;
    let product = a * b;
    sum + product  // 10 + 20 + 200 = 230
}

// ============================================================================
// Example 3: Variable Mutation
// ============================================================================

fn mutation_demo() -> i32 {
    let mut counter = 0;
    counter = counter + 1;
    counter = counter + 2;
    counter = counter + 3;
    counter  // 6
}

// ============================================================================
// Example 4: If Expression
// ============================================================================

fn abs_value(x: i32) -> i32 {
    if x < 0 {
        -x
    } else {
        x
    }
}

fn if_demo() -> i32 {
    abs_value(-10) + abs_value(20)  // 10 + 20 = 30
}

// ============================================================================
// Example 5: While Loop
// ============================================================================

fn sum_range(start: i32, end: i32) -> i32 {
    let mut sum = 0;
    let mut i = start;

    while i <= end {
        sum = sum + i;
        i = i + 1
    };

    sum
}

fn loop_demo() -> i32 {
    sum_range(1, 10)  // 55
}

// ============================================================================
// Example 6: Nested Loops
// ============================================================================

fn multiplication_table() -> i32 {
    let mut count = 0;
    let mut i = 1;

    while i <= 3 {
        let mut j = 1;
        while j <= 3 {
            count = count + 1;
            j = j + 1
        };
        i = i + 1
    };

    count  // 3 * 3 = 9
}

// ============================================================================
// Example 7: Function Calls
// ============================================================================

fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

fn call_demo() -> i32 {
    add(10, 20) + multiply(3, 4)  // 30 + 12 = 42
}

// ============================================================================
// Example 8: Recursion
// ============================================================================

fn factorial(n: i32) -> i32 {
    if n <= 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}

fn factorial_demo() -> i32 {
    factorial(5)  // 120
}

fn fibonacci(n: i32) -> i32 {
    if n <= 1 {
        n
    } else {
        fibonacci(n - 1) + fibonacci(n - 2)
    }
}

fn fib_demo() -> i32 {
    fibonacci(10)  // 55
}

// ============================================================================
// Example 9: Struct Usage
// ============================================================================

struct Point {
    x: i32,
    y: i32
}

fn distance_squared(p1: Point, p2: Point) -> i32 {
    let dx = p2.x - p1.x;
    let dy = p2.y - p1.y;
    dx * dx + dy * dy
}

fn struct_demo() -> i32 {
    let p1 = Point { x: 0, y: 0 };
    let p2 = Point { x: 3, y: 4 };
    distance_squared(p1, p2)  // 25 (3-4-5 triangle)
}

// ============================================================================
// Example 10: Enum and Match
// ============================================================================

enum Color {
    Red,
    Green,
    Blue
}

fn color_to_int(c: Color) -> i32 {
    match c {
        Color::Red => 1,
        Color::Green => 2,
        Color::Blue => 3
    }
}

enum Option {
    Some(i32),
    None
}

fn unwrap_or_default(opt: Option) -> i32 {
    match opt {
        Option::Some(val) => val,
        Option::None => 0
    }
}

fn enum_demo() -> i32 {
    let color = Color::Red;
    let value = Option::Some(42);
    let nothing = Option::None;

    color_to_int(color) + unwrap_or_default(value) + unwrap_or_default(nothing)
    // 1 + 42 + 0 = 43
}

// ============================================================================
// Example 11: Tuple
// ============================================================================

fn tuple_demo() -> i32 {
    let pair = (10, 20);
    let (x, y) = pair;
    x + y  // 30
}

// ============================================================================
// Example 12: Complex Control Flow
// ============================================================================

fn sign(x: i32) -> i32 {
    if x < 0 {
        -1
    } else if x == 0 {
        0
    } else {
        1
    }
}

fn max_of_three(a: i32, b: i32, c: i32) -> i32 {
    let mut max = a;

    if b > max {
        max = b
    };

    if c > max {
        max = c
    };

    max
}

fn control_flow_demo() -> i32 {
    sign(-5) + sign(0) + sign(10) + max_of_three(1, 5, 3)
    // -1 + 0 + 1 + 5 = 5
}

// ============================================================================
// Example 13: Counters and Accumulators
// ============================================================================

fn count_even(n: i32) -> i32 {
    let mut count = 0;
    let mut i = 1;

    while i <= n {
        if i % 2 == 0 {
            count = count + 1
        };
        i = i + 1
    };

    count
}

fn accumulator_demo() -> i32 {
    count_even(10)  // 5 (2, 4, 6, 8, 10)
}

// ============================================================================
// Example 14: Power Function
// ============================================================================

fn power(base: i32, exp: i32) -> i32 {
    let mut result = 1;
    let mut i = 0;

    while i < exp {
        result = result * base;
        i = i + 1
    };

    result
}

fn power_demo() -> i32 {
    power(2, 10)  // 1024
}

// ============================================================================
// Example 15: Greatest Common Divisor (Euclidean Algorithm)
// ============================================================================

fn gcd(a: i32, b: i32) -> i32 {
    if b == 0 {
        a
    } else {
        gcd(b, a % b)
    }
}

fn gcd_demo() -> i32 {
    gcd(48, 18)  // 6
}

// ============================================================================
// Main Function - Run All Demos
// ============================================================================

fn main() -> i32 {
    // Uncomment one at a time to test

    say_hello();
    0  // Return 0 for success

    // To test other demos, change return value:
    // arithmetic_demo()        // 230
    // mutation_demo()          // 6
    // if_demo()               // 30
    // loop_demo()             // 55
    // multiplication_table()  // 9
    // call_demo()             // 42
    // factorial_demo()        // 120
    // fib_demo()              // 55
    // struct_demo()           // 25
    // enum_demo()             // 43
    // tuple_demo()            // 30
    // control_flow_demo()     // 5
    // accumulator_demo()      // 5
    // power_demo()            // 1024
    // gcd_demo()              // 6
}

// ============================================================================
// Compilation Instructions
// ============================================================================
//
// To compile and run:
//   yan run working_demo.zl
//
// To build executable:
//   yan build working_demo.zl
//   ./working_demo
//
// Expected output: "Hello, World!" and exit code 0
//
// All functions above are tested and verified to work correctly.
// Modify main() to return different function results.
// ============================================================================
